# ==================================================
# Path: E:\Dai Hoc\Lap trinh web\DoAn-LapTrinhWeb
# Detected tech: javascript, typescript
# ==================================================

## DIRECTORY STRUCTURE
```
DoAn-LapTrinhWeb/
├── .git/
├── Backend/
│   ├── config/
│   │   └── .gitkeep
│   ├── controllers/
│   │   ├── .gitkeep
│   │   └── authController.js
│   ├── middleware/
│   │   ├── .gitkeep
│   │   └── authMiddleware.js
│   ├── models/
│   │   ├── .gitkeep
│   │   ├── Otp.js
│   │   └── User.js
│   ├── node_modules/
│   ├── routes/
│   │   ├── .gitkeep
│   │   └── auth.js
│   ├── uploads/
│   │   └── .gitkeep
│   ├── .env
│   ├── app.js
│   ├── package-lock.json
│   └── package.json
├── Frontend/
│   ├── Public/
│   │   ├── .gitkeep
│   │   ├── adminND.html
│   │   ├── adminTL.html
│   │   ├── adminTQ.html
│   │   ├── blog-post.html
│   │   ├── blog-read.html
│   │   ├── blog.html
│   │   ├── document.html
│   │   ├── forgot.html
│   │   ├── index.html
│   │   ├── login.html
│   │   ├── mon-chinh-tri.html
│   │   ├── mon-chuyen-nganh.html
│   │   ├── mon-co-so-nganh.html
│   │   ├── mon-dai-cuong.html
│   │   ├── mon-tu-chon.html
│   │   ├── reset.html
│   │   ├── signup.html
│   │   ├── standard.html
│   │   ├── template.html
│   │   ├── upload1.html
│   │   ├── userQL.html
│   │   └── userTK.html
│   ├── assets/
│   │   ├── .gitkeep
│   │   ├── img-avatar-1.webp
│   │   ├── img-avatar-2.jpg
│   │   ├── img-blog-1.webp
│   │   ├── img-blog-2.webp
│   │   ├── img-blog-3.webp
│   │   ├── img-blog-4.webp
│   │   ├── img-blog-5.webp
│   │   ├── img-blog-6.webp
│   │   ├── img-blog-7.webp
│   │   ├── img-blog-8.webp
│   │   ├── inntroduce-content-img.jpg
│   │   ├── login_pic.jpg
│   │   ├── logo-uit.png
│   │   ├── logo-web-full.png
│   │   ├── logo-web.png
│   │   └── main-page-banner.png
│   ├── css/
│   │   ├── .gitkeep
│   │   ├── adminND.css
│   │   ├── adminTL.css
│   │   ├── adminTQ.css
│   │   ├── blog-post.css
│   │   ├── blog-read.css
│   │   ├── blog.css
│   │   ├── document.css
│   │   ├── forgot.css
│   │   ├── index.css
│   │   ├── login.css
│   │   ├── main.css
│   │   ├── reset.css
│   │   ├── signup.css
│   │   ├── standard.css
│   │   ├── upload1.css
│   │   ├── userQL.css
│   │   └── userTK.css
│   ├── js/
│   │   ├── .gitkeep
│   │   ├── blog-post.js
│   │   ├── blog-read.js
│   │   ├── blog.js
│   │   ├── document.js
│   │   ├── forgot.js
│   │   ├── index.js
│   │   ├── login.js
│   │   ├── main.js
│   │   ├── reset.js
│   │   ├── set-title.js
│   │   ├── signup.js
│   │   └── upload1.js
│   ├── json/
│   │   └── data.json
│   └── pages/
│       └── .gitkeep
├── .gitignore
└── README.md
```

## FILE CONTENTS

### Backend\app.js
```js
const express = require('express');
const mongoose = require('mongoose');
const session = require('express-session');
const MongoStore = require('connect-mongo');
const cors = require('cors');
const path = require('path');
require('dotenv').config();

const app = express();

// CORS: Cho phép frontend truy cập với session
app.use(cors({
    origin: ['http://localhost:5500', 'http://127.0.0.1:5500'],
    credentials: true, // Cần có để gửi cookie qua frontend
}));

app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Kết nối MongoDB
mongoose.connect(process.env.MONGO_URI, {
    useNewUrlParser: true,
    useUnifiedTopology: true
})
.then(() => console.log('MongoDB Atlas connected'))
.catch(err => console.error('Error connecting to MongoDB:', err));

// Session middleware
app.use(session({
    secret: process.env.SESSION_SECRET || 'default_secret_key',
    resave: false,
    saveUninitialized: false,
    cookie: {
        maxAge: 1000 * 60 * 60,
        httpOnly: true,
        secure: false, // true nếu dùng HTTPS
    },
    store: MongoStore.create({
        mongoUrl: process.env.MONGO_URI,
        collectionName: 'sessions'
    })
}));

// Serve static files (HTML, CSS, JS)
app.use(express.static(path.join(__dirname, 'Public')));

// Routes
const authRoutes = require('./routes/auth');
const authMiddleware = require('./middleware/authMiddleware'); 

app.use('/api/auth', authRoutes);

// Route trả thông tin người dùng
app.get('/api/user-info', authMiddleware, (req, res) => {
    res.json({
        username: req.session.user.username,
        email: req.session.user.email
    });
});

// Route dashboard bảo vệ, trả về index.html
app.get('/dashboard', authMiddleware, (req, res) => {
    res.sendFile(path.join(__dirname, 'Public/index.html'));
});

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));

```

### Backend\controllers\authController.js
```js
const bcrypt = require('bcryptjs');
const nodemailer = require('nodemailer');
const Otp = require('../models/Otp');
const User = require('../models/User');

//Đăng ký
exports.register = async(req, res) => {
    const {username, email, password} = req.body;
    try {
        const existingUser = await User.findOne({ email });
        if (existingUser) 
            return res.status(400).json({ msg: 'Email already exists' });

        const hashedPassword = await bcrypt.hash(password, 10);
        const newUser = new User({ username, email, password: hashedPassword });
        await newUser.save();
        
        res.status(201).json({ msg: 'Registered successfully' });
    } catch (err) {
        res.status(500).json({msg: 'Server error'});
    }
}

//Đăng nhập
exports.login = async(req, res) => {
    const {email, password} = req.body;
    try {
        const user = await User.findOne({ email });
        if (!user) 
            return res.status(400).json({ msg: 'Invalid credentials' });

        const isMatch = await bcrypt.compare(password, user.password);
        if (!isMatch)
            return res.status(400).json({ msg: 'Invalid credentials' });

        req.session.user = {
            id: user._id,
            username: user.username,
            email: user.email
        }

        res.json({ msg: 'Login successful', redirect: '/dashboard' })
    } catch (err) {
        res.status(500).json({ msg: 'Server error' });
    }
}

//Đăng xuất
exports.logout = (req, res) => {
    req.session.destroy((err) => {
        if (err) 
            return res.status(500).json({ msg: 'Logout failed' });
        res.clearCookie('connect.sid');
        res.json({ msg: 'Logged out successfully' });
    })
}

//Gửi Otp
const transporter = nodemailer.createTransport({
    service: 'gmail',
    auth: {
        user: process.env.EMAIL_USER,     // email của bạn
        pass: process.env.EMAIL_PASS      // mật khẩu hoặc app password
    }
});

function generateOTP() {
    return Math.floor(100000 + Math.random() * 900000).toString();
}


exports.sendOtp = async(req, res) => {
    const {email} = req.body;

    if (!email) 
        return res.status(400).json({ msg: 'Email là bắt buộc' });

    try {
        const otp = generateOTP();
        const expiresAt = new Date(Date.now() + 5 * 60 * 1000); // 5 phút

        await Otp.findOneAndUpdate(
            { email },
            { otp, expiresAt },
            { upsert: true, new: true, setDefaultsOnInsert: true }
        );

        const mailOptions = {
            from: process.env.EMAIL_USER,
            to: email,
            subject: 'Mã OTP đăng ký tài khoản WeShare',
            text: `Mã OTP của bạn là: ${otp}. Mã có hiệu lực trong 5 phút.`
        };

        await transporter.sendMail(mailOptions);
        return res.json({ msg: 'Đã gửi OTP về email' });
    } catch (error) {
        console.error('Lỗi gửi OTP:', error);
        return res.status(500).json({ msg: 'Gửi email thất bại' });
    }
};


//Xác thực Otp
exports.verifyOtp = async (req, res) => {
    const { email, otp } = req.body;

    if (!email || !otp) {
        return res.status(400).json({ msg: 'Thiếu email hoặc OTP' });
    }

    try {
        const record = await Otp.findOne({ email, otp });
        if (!record) {
            return res.status(400).json({ msg: 'OTP không đúng' });
        }

        if (record.expiresAt < new Date()) {
            await Otp.deleteOne({ _id: record._id });
            return res.status(400).json({ msg: 'OTP đã hết hạn' });
        }

        await Otp.deleteOne({ _id: record._id });
        return res.status(200).json({ msg: 'OTP hợp lệ' });

    } catch (err) {
        console.error('Lỗi verifyOtp:', err);
        return res.status(500).json({ msg: 'Lỗi server' });
    }
};

//Kiểm tra trạng thái đăng nhập
exports.getSession = async(req, res) => {
    if (req.session.user) {
        return res.json({ loggedIn: true, user: req.session.user });
    } else {
        return res.json({ loggedIn: false });
    }
}

```

### Backend\middleware\authMiddleware.js
```js
module.exports = (req, res, next) => {
    if (!req.session.user) {
        return res.status(401).json({ msg: 'Unauthorized' });
    }
    next();
}
```

### Backend\models\Otp.js
```js
const mongoose = require('mongoose');

const otpSchema = new mongoose.Schema({
    email: { type: String, required: true, unique: true },
    otp: { type: String, required: true },
    expiresAt: { type: Date, required: true },
}, {
    timestamps: true
});

// Tự động xóa document khi quá hạn (TTL index)
otpSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });

module.exports = mongoose.model('Otp', otpSchema);

```

### Backend\models\User.js
```js
const mongoose = require('mongoose');

const UserSchema = new mongoose.Schema({
    username: {type: String, required: true, unique: true},
    email: {type: String, required: true, unique: true},
    password: {type: String, required: true}
})

module.exports = mongoose.model('User', UserSchema);
```

### Backend\routes\auth.js
```js
const express = require('express');
const router = express.Router();
const authController =  require('../controllers/authController');
const authMiddleware = require('../middleware/authMiddleware');
const path = require('path');

//Đăng ký
router.post('/register', authController.register);

//Đăng nhập
router.post('/login', authController.login);

//Đăng xuất
router.post('/logout', authController.logout);

//Gửi otp
router.post('/send-otp', authController.sendOtp);

//Kiểm tra otp
router.post('/verify-otp', authController.verifyOtp);

//Kiểm tra trạng thái đăng nhập
router.post('/get-session', authController.getSession);

// Route bảo vệ - chỉ cho user đã đăng nhập
router.get('/dashboard', authMiddleware, (req, res) => {
    res.sendFile(path.join(__dirname, '../Public/index.html'));
});

// Trả thông tin người dùng
router.get('/api/user-info', authMiddleware, (req, res) => {
    res.json({
        username: req.session.user.username,
        email: req.session.user.email
    });
});


module.exports = router;
```

### Frontend\js\blog-post.js
```js
function toggleMenu() {
    const menu = document.getElementById("side-nav");
    menu.classList.toggle("active");
    document.body.classList.toggle("sidebar-open");
}

function toggleSubmenu(element) {
    const subMenu = element.nextElementSibling;
    if (subMenu && subMenu.classList.contains('sub-menu')) 
    {
        subMenu.style.display = (subMenu.style.display === 'flex') ? 'none' : 'flex';

        const icon = element.querySelector('i');
        if (icon) {
            icon.classList.toggle('fa-chevron-down');
            icon.classList.toggle('fa-chevron-up');
        }
    }
}
let savedRange = null;

document.addEventListener("DOMContentLoaded", function () {
    const postContent = document.getElementById("postContent");
    const emojiBtn = document.querySelector('.fa-smile');
    const emojiPicker = document.getElementById('emojiPicker');

    // Ghi nhớ vị trí con trỏ
    postContent.addEventListener("mouseup", saveCursorPosition);
    postContent.addEventListener("keyup", saveCursorPosition);

    function saveCursorPosition() {
        const selection = window.getSelection();
        if (selection.rangeCount > 0 && postContent.contains(selection.anchorNode)) {
            savedRange = selection.getRangeAt(0);
        }
    }

    // Toggle Emoji Picker
    emojiBtn.addEventListener('click', function () {
        emojiPicker.style.display = emojiPicker.style.display === 'none' ? 'block' : 'none';
    });

    // Chèn emoji
    emojiPicker.addEventListener('emoji-click', event => {
        const emoji = event.detail.unicode;

        const span = document.createElement("span");
        span.textContent = emoji;
        span.style.display = "inline-block";

        const selection = window.getSelection();

        if (selection.rangeCount > 0 && postContent.contains(selection.anchorNode)) {
            const range = selection.getRangeAt(0);
            range.deleteContents();
            range.insertNode(span);
            range.setStartAfter(span);
            range.collapse(true);
            selection.removeAllRanges();
            selection.addRange(range);
            savedRange = range; // ✅ Cập nhật lại savedRange sau khi chèn emoji
        } else if (savedRange) {
            const range = savedRange;
            range.deleteContents();
            range.insertNode(span);
            range.setStartAfter(span);
            range.collapse(true);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
            savedRange = range;
        } else {
            postContent.insertAdjacentElement("beforeend", span);
        }

        emojiPicker.style.display = 'none';
    });
});

// Hàm chèn ảnh
function insertImage() {
    const fileInput = document.getElementById("imageUpload");
    const file = fileInput.files[0];
    const postContent = document.getElementById("postContent");

    if (file && postContent) {
        const reader = new FileReader();
        reader.onload = function (e) {
            const imgElement = document.createElement("img");
            imgElement.src = e.target.result;
            imgElement.style.maxWidth = "80%";
            imgElement.style.maxHeight = "300px";
            imgElement.style.height = "auto";
            imgElement.style.display = "block";
            imgElement.style.margin = "10px 0";

            if (savedRange) {
                const range = savedRange;
                range.deleteContents();
                range.insertNode(imgElement);
                range.setStartAfter(imgElement);
                range.collapse(true);

                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);

                savedRange = range; // ✅ Cập nhật lại savedRange sau khi chèn ảnh
            } else {
                postContent.appendChild(imgElement);
            }
        };
        reader.readAsDataURL(file);
    }
}

function submitPost() {

    const postContent = document.getElementById("postContent");
    postContent.innerHTML = '';
    const imageInput = document.getElementById("imageUpload");
    imageInput.value = '';
}
```

### Frontend\js\blog-read.js
```js
function toggleMenu() {
    const menu = document.getElementById("side-nav");
    menu.classList.toggle("active");
    document.body.classList.toggle("sidebar-open");
}

function toggleSubmenu(element) {
    const subMenu = element.nextElementSibling;
    if (subMenu && subMenu.classList.contains('sub-menu')) 
    {
        subMenu.style.display = (subMenu.style.display === 'flex') ? 'none' : 'flex';

        const icon = element.querySelector('i');
        if (icon) {
            icon.classList.toggle('fa-chevron-down');
            icon.classList.toggle('fa-chevron-up');
        }
    }
}
const posts = {
  siem: {
    title: "SIEM Roadmap",
    date: "April 28, 2025",
    image: "../assets/img-blog-1.webp",
    content: `
      <p>SIEM? Nếu các bạn làm an toàn vận hành thì SIEM là giải pháp không thể thiếu và bài viết hôm nay mình sẽ chia sẻ công việc liên quan đến nó, hi vọng những chia sẻ có thể giúp được các bạn phần nào khi làm An toàn vận nói chung và SIEM nói riêng.</p>
      <p>Trước khi đi vào chi tiết, mình giới thiệu qua về SIEM - Đây là một hệ thống quản lý an toàn thông tin tập trung, cho phép thu thập dữ liệu log từ nhiều nguồn để lưu trữ tập trung, thực hiện tương quan (correlation) và phân tích, xử lý để phát hiện các hành vi bất thường liên quan đến hệ thống công nghệ thông tin trong một tổ chức.</p>
      <p>Tùy từng vào môi trường lab nghiên cứu hay Enterprise ở các công ty lớn thì cũng sẽ có các yêu cầu khác nhau, nên với mỗi vấn đề mình sẽ trình bày dựa trên góc nhìn của cá nhân.</p>
    `
  },
  blockchain: {
    title: "Blockchain Roadmap",
    date: "April 28, 2025",
    image: "../assets/img-blog-2.webp",
    content: `
      <p></p>
      <p></p>
      <p></p>
      <p></p>
    `
  },
  pentester: {
    title: "pEnTester Roadmap",
    date: "April 28, 2025",
    image: "../assets/img-blog-3.webp",
    content: `
      <p>Hello các bạn, nếu đã đọc được những dòng này nghĩa là bạn có quan tâm đến việc trở thành 1 pentester đúng không? Ok, với gần 5 năm kinh nghiệm thực tiễn và 50 năm kinh nghiệm OT, hy vọng mình có thể chia sẽ cho các bạn hình dung được bức tranh về ngành này 😀</p>
      <p>Nhắc đến pentest thì nhiều bạn sẽ nghĩ ngay đến Web Exploit, thật ra pentest là khái niệm chung, và không có giới hạn, bạn có thể pentest web, Mobile, các thiết bị IoT, các hệ điều hành tự chế (như của các kiosk ATM ngân hàng), thiết bị phần cứng khi được yêu cầu.</p>
      <p>Mình bắt đầu “pentest” sau 2 năm chơi CTF mảng web và mobile</p>
      <p>Vào tầm năm 2015, mình bắt đầu thực tập trong tập đoàn “H” ở quận 7 và dự án đầu tiên mình được giao là target 1 cái CMS =)) đơ người, mò được vài cái XSS nhưng không có “phê” như lúc chơi CTF ra flag, lúc này mình nhận ra pentest và CTF là 2 lĩnh vực khác nhau, có thể bổ trợ cho nhau, nhưng về cơ bản vẫn cứ là khác nhau.</p>
    `
  },
  malware: {
    title: "Malware Analyst Roadmap",
    date: "April 28, 2025",
    image: "../assets/img-blog-4.webp",
    content: `
      <p>Chào các bạn đến với môn Phòng chống nghệ thuật hắc ám – Phòng chống mã độc</p>
      <p>Nếu các bạn đã quyết định tìm hiểu nghề này, thì cũng xin giới thiệu đó là một trong 4 nhóm nghề mà anh ThaiDN có nhắc tới [1]. Công việc chính của chúng ta làm trong một doanh nghiệp đó là tìm kiếm, phân tích, và tiêu diệt mã độc bao gồm các cuộc tấn công có chủ đích. Mã độc có thể là virus máy tính, trojan hay các loại malware nói chung và các mã khai thác 0-day chưa được biết đến.</p>
      <p>Đương nhiên, trong thực tế công việc mà tôi đã trải nghiệm ở một vài công ty tại Việt Nam thì còn cần nâng cấp các hệ thống hiện tại để chống lại các kỹ thuật của mã độc, tối ưu hệ thống để phát hiện các loại mã độc chưa được biết đến, xây dựng hệ thống phân tích mã độc tự động, xây dựng quy trình xử lý sự cổ – phản ứng khi có tấn công mã độc,… Công việc này có vẻ sẽ rất khó khăn và cần đến các kiến thức cơ bản nhất của ngành Công nghệ thông tin như: Lập trình ngôn ngữ bậc thấp, lập trình ngôn ngữ bậc cao, hay nói chung là cần phải biết và có thể làm việc được với hầu hết các ngôn ngữ lập trình. Vì mã độc có thể tồn tại ở bất kỳ dạng ngôn ngữ lập trình nào. Có am hiểu về kiến trúc Hệ điều hành, kiến trúc vi xử lý trên nhiều nền tảng khác nhau. Tuy nhiên, cũng cần lưu ý rằng không yêu cầu bạn phải ghi nhớ và biết hết mọi kiến thức. Ví dụ có thể tra cứu các câu lệnh của Intel x64 khi bạn chưa nhớ hết được toàn bộ các câu lệnh, nhưng yêu cầu cần phải biết được các lệnh cơ bản.</p>
      <p>Nói là phải biết nhiều như thế, nhưng chăm chỉ luyện tập và thực hành nhiều sẽ quen dần với công việc, và đến một lúc nào đó bạn có thể hiểu mã độc như những người lập trình ra nó.</p>
    `
  },
  pwnable:
  {
    title: "Pwnable Roadmap",
    date: "April 28, 2025",
    image: "../assets/img-blog-5.webp",
    content: `
      <p>Chào mừng các bạn đến với bài viết của mình, mình là @chung96vn. Chia sẻ một chút về con đường sự nghiệp của mình. Ngày trước chưa bao giờ mình nghĩ là sẽ theo đuổi ngành ATTT mà theo vào đó là CNPM hoặc KHMT. Tuy nhiên dòng đời xô đẩy và số phận đã đưa mình đến với ngành ATTT. Mình đã trải qua một quãng thời gian đầu đầy vất vả. Mình không có điều kiện tốt như những người bạn khác là được đi thực tập, được training bởi các anh đi trước mà mình phải tự tìm hiểu, tự học bằng tất cả những gì mình có thể. Mình tự học qua CTF, qua các trang web như root-me, pwnable.tw, pwnable.kr, reverse.kr,…. Có những lúc mình rơi vào bế tắc và rồi lại tìm được một tia nắng cuối con đường. Mình không giống như nhiều anh em khác là đi theo một con đường từ đầu tới cuối, mình đã bắt đầu với crypto và kế tiếp là reverse rồi mình bén duyên với pwnable (cái mà mình thấy hợp và phát huy hết được khả năng của mình) xong cuối cùng lúc đi làm mình lại làm nhiều về web application security.</p>
      <p>Trước khi đi vào Roadmap thì mình muốn nhấn mạnh lại một điều là những gì mình viết dưới đây phần lớn là kinh nghiệm của bản thân mình, là những gì mình đã trải qua để có được ngày hôm này, có thể nó không đúng với cá nhân các bạn. Mình cũng cố gắng đi tham khảo thêm các thông tin từ những người anh em xã hội khác của mình trước khi viết bài này nên mình nghĩ bài viết này sẽ giúp được các bạn nếu các bạn thực sự cố gắng. Sẽ chẳng có con đường nào dành cho những người lười nhác hoặc không làm mà muốn ăn cả.</p>
      <p>Đầu tiên nếu như bạn đang chưa biết gì và muốn tìm hiểu về mảng pwnable này mình nghĩ bạn cần phải nhìn lại bản thân mình đang có những kiến thức gì và thiếu gì. Bạn có thể xem những thứ mình liệt kê dưới đây để có thể đánh giá một cách chính xác nhất về bản thân mình hiện tại.</p>
      <p>Đừng lo nếu bạn chưa biết những thứ đó, hãy bắt tay vào học nó ngay khi bạn còn có thể. Mình sẽ không đi quá chi tiết vào học từng cái như nào bởi mình nghĩ trên mạng đang có rất nhiều mà mình chỉ đưa ra một số gợi ý theo cá nhân mình thấy nó khá là basic để ai cũng có thể học đc.</p>
    `
  },
  RER:
  {
    title: "Reverse Engineering Roadmap",
    date: "April 28, 2025",
    image: "../assets/img-blog-6.webp",
    content: `
      <p>Khi mình chọn ngành chọn trường thi đại học, chỉ nghĩ đơn giản là chọn ngành nào ra sau này dễ xin việc, kiếm được tiền 💰. Hồi đó chọn ngành an toàn thông tin chỉ vì nghe nó mới và lạ, có lẽ sẽ ít phải cạnh tranh so với ngành công nghệ thông tin. Vào đại học không giống như các thần đồng trong ngành mà mình biết, 2 năm đầu mình chỉ học theo chương trình trên lớp, lập trình/acm rồi các môn cơ sở ngành gần như không hề có khái niệm về Security là gì và cũng không biết làm Security thì phải học như nào (có lẽ cũng do bản thân mình lười không tự tìm hiểu). Bước ngoặt của mình là rơi vào năm học thứ 3, mình nghe được nhiều tin tuyển dụng về Security hơn, tham gia thi tuyển, xin thực tập và mình may mắn được vào Viettel. Ở đây mình mới bắt đầu có những tư duy về Security cũng như là nơi đào tạo mình để mình được như bây giờ.</p>
      <p>Mình bắt đầu tiếp xúc với reverse engineering qua các challenge nhỏ mà mình được đào tạo ở Viettel, sau đó thì bắt đầu chơi CTF. Tham gia cũng nhiều cuộc thi CTF trong và ngoài nước nhưng cũng không có thành tích gì mấy. Ở đây mình sẽ chia sẻ cho các bạn biết về những thứ mình đã học, luyện khi tiếp xúc với reverse engineering, tất nhiên mình sẽ không nói về các khái niệm, thống kê cũng như phân loại nó vì đơn giản mình không biết đủ rộng để làm việc đó (nếu thắc mắc về khái niệm các bạn có thể tự Google). Chỉ là quan điểm cá nhân do mình rút ra có thể đúng hoặc sai nhưng mình vẫn hi vọng sẽ giúp cho những bạn mới muốn tìm hiểu và đi theo security nói chung và Reverse Engineering nói riêng.</p>
      <p>Chắc nhiều người nghĩ học lập trình thì đi làm coder làm thế mẹ nào được hacker. Nếu nghĩ thế thì bạn đã nhầm hoàn toàn, ở đây khả năng Reverse của bạn sẽ tỉ lệ thuận với khả năng lập trình. Đặt vào 1 trường hợp cụ thể khi bạn Reverse 1 đoạn mã trong 1 ngữ cảnh nào đó, nếu bạn đã từng lập trình và hiểu nó rồi thì khi Reverse sẽ biết ngay là tác giả đang làm gì và muốn làm gì, còn nếu bạn chứ từng lập trình thì sẽ mất khá nhiều thời gian để bạn hiểu được đoạn mã đó.</p>
      <p>Học lập trình thì nên học như thế nào? Đối với mình thì mình khuyên các bạn nên học tư duy lập trình, không nên học tràn lan nhiều ngôn ngữ. Tư duy lập trình là kiểu bạn nhìn nhận giải quyết vấn đề đó từ nhỏ đến lớn sau đó sẽ đưa ra các giải pháp. Khi bạn hình thành được tư duy lập trình thì bạn chỉ cần học 1 ngôn ngữ các ngôn ngữ khác sẽ chỉ khác cú pháp còn lại mọi thứ đều năm ở tư duy lập trình. Chỉ mất 1 đến 2 tháng là bạn có thể thành thạo lập trình trên ngôn ngữ mới.</p>
    `
  },
  WAFE:
  {
    title: "Web Application Firewall Exploit: If you cannot protect yourself, who can you protect?",
    date: "April 28, 2025",
    image: "../assets/img-blog-7.webp",
    content: `
      <p>Hi guys,
         As my previous article about web application firewall (WAF) bypass / exploit series, today I will write my experience when exploit another popular WAF from a local vendor in Vietnam which also has a bug bounty platform, this is the first time I reported a vulnerability to a bug bounty platform in Vietnam. However, due to the limited disclosure ?!? from that vendor (why limited? I will explain in the end of this article), I will name the vendor in my article is Company-X, name the vulnerable WAF is WAF-DIRTYCLOUD and name the bug bounty platform is Platform–Z. Okay let’s go.</p>
      <p>I and my teammate 0m3g4 did some notice about Company-X structure and got an interested thing. We found that multiple Company-X sites were implemented WAF-DIRTYCLOUD / load balancer. Basically WAF-DIRTYCLOUD itself vulnerable to CRLF injection. So, we chain 02 security vulnerabilities and can trigger XSS from victim side and block victim access to any vulnerable site due to incorrect cookie implement.</p>
      <p>So, when a site / page was protected by a WAF and this WAF also had a security vulnerability ¯_(ツ)_/¯</p>
    `
  },
  WASR:
  {
    title: "Web Application Security Roadmap",
    date: "April 28, 2025",
    image: "../assets/img-blog-8.webp",
    content: `
      <p>Hi guys,
        Như các thông báo đã được đăng trên fanpage của hackemall, trong chuỗi các topic của HackerDEX, hôm nay mình xin được chia sẻ con đường mình đã đi cũng như kinh nghiệm của mình về một mảng mà đa số các script kiddies / hacker / gosu … đều đã từng trải qua: Web Application Security (WebSec). Hi vọng roadmap này sẽ giúp ít cho các bạn đã và đang mới bắt đầu hay đang gặp khó khăn, stuck, betak đối với mảng web, giúp cho các bạn tiết kiệm về thời gian, có một cái nhìn tổng quan, cụ thể về mảng này. Okay let’s go.</p>
      <p>Mình tiếp xúc với web security cũng như các cuộc thi Capture The Flag (CTF) ngay từ trước những ngày đầu nhập học của đời sinh viên (2014), chinh chiến, vỡ mồm cũng nhiều :D, cũng đạt được một vài thành tựu đối với các giải CTF trong nước lẫn nước ngoài. Lúc đầu mình chơi tất cả các mảng, sau này mình đi sâu và sâu hơn vào mảng web. Mình sẽ hệ thống lại những gì mình đã học, luyện khi chân ướt chân ráo bước vào thế giới World Wide Web.</p>
      <p>Đối với tất cả những bạn đã từng tiếp xúc với WebSec khi chơi CTF hoặc vọc vạch một trang web nào đó, cảm giác sẽ rất dễ chịu, bạn cảm thấy rằng bạn có thể mò tới mọi thứ, mọi ngóc ngách của trang web đó. Chính vì thế, đây là mảng dễ chơi nhất và ai cũng đều có thể trở thành :hackerman:</p>
      <p>Tuy nhiên không có gì là dễ dàng, mảng web tuy dễ tiếp cận nhưng theo trải nghiệm của mình từ trước đến nay, đa số những bạn được gọi là “đam mê” hack web đều sẽ dừng lại ở một mức nào đó và không đi xa, đi sâu hơn trên con đường này. Kiến trúc của mảng này nó như một cái phễu ngược , càng đi sâu càng khó và rất rất đa dạng, vì thế nhiều người sẽ bỏ cuộc khi bị stuck, betak gaming, mất phương hướng. </p>
    `
  },
  forensic:
  {
    title: "Forensic Roadmap",
    date: "April 28, 2025",
    image: "../assets/img-avatar-1.webp",
    content: `
      <p>Digital Forensics (điều tra số) là một nhánh của ngành khoa học điều tra đề cập đến việc sử dụng các phương pháp, công cụ kỹ thuật khoa học đã được chứng minh để thu thập, bảo quản và phân tích dữ liệu trong các thiết bị kỹ thuật số với mục tiêu tìm kiếm các chứng cứ thuyết phục để tái hiện lại các sự kiện đã và đang diễn ra nhằm xác định các hành vi phạm tội hay hỗ trợ cho việc dự đoán các hoạt động trái phép như cố ý xâm nhập, tấn công hoặc gây gián đoạn quá trình hoạt động của hệ thống.</p>
      <p>Khi nào thì thực sự cần thiết thực hiện một cuộc điều tra số?

        Khi hệ thống bị tấn công mà chưa xác định được nguyên nhân.
        Khi cần thiết khôi phục dữ liệu trên thiết bị, hệ thống đã bị xóa đi
        Khi thực hiện điều tra tội phạm có liên quan đến công nghệ cao
        Điều tra sự gian lận trong tổ chức
        Điều tra các hoạt động gián điệp công nghiệp</p>
      <p>Ngày nay dữ liệu số có mặt ở khắp mọi nơi, từ máy tính cho đến các thiết bị di động, thiết bị PDA, GPS, máy tính bảng. Tuy nhiên trong phạm vi bài viết này, mình chỉ giới thiệu một số loại hình điều tra số trên máy tính bao gồm:

        Phân tích điều tra dữ liệu trên ổ cứng: Là việc thu thập, phân tích dữ liệu được lưu trữ trên phương tiện lưu trữ vật lý, từ đó trích xuất các dữ liệu ẩn, khôi phục các tập tin bị xóa, qua đó xác định người đã tạo ra những thay đổi dữ liệu trên thiết bị được phân tích, cũng như tìm kiếm những bằng chứng liên quan đến hoạt động xâm nhập, gian lận…
        Phân tích điều tra dữ liệu mạng: Là một nhánh của điều tra số liên quan đến việc theo dõi, giám sát, phân tích lưu lượng mạng máy tính nhằm phục vụ cho việc thu thập thông tin, sự kiện liên quan,để phát hiện sự bất thường, các dấu hiệu xâm nhập trên môi trường mạng.
        Phân tích điều tra dữ liệu trên RAM: Là phương thức điều tra máy tính bằng việc sử dụng kiến trúc quản lý bộ nhớ trong máy tính để ánh xạ, trích xuất các tập tin đang thực thi và cư trú trong bộ nhớ RAM tại thời điểm hệ thống đang hoạt động, sau đó tiến hành phân tích làm rõ các hành vi đang xảy ra trên hệ thống..</p>
      <p>Sau khi giới thiệu qua về khái niệm và một số loại hình điều tra số phổ biến, chắc mọi người đã có được những hình dung ban đầu về lĩnh vực này. Vậy bây giờ chúng ta nên tiếp cận như thế nào? Sau đây mình đưa ra một số gợi ý mà các bạn có thể tham khảo để xây dựng cho mình một lộ trình tốt.

        Nắm bắt được quy trình thực hiện bao gồm các bước:
        Chuẩn bị: Thực hiện việc mô tả lại thông tin hệ thống, những gì đã xảy ra, các dấu hiệu, để xác định phạm vi điều tra, mục đích cũng như các tài nguyên cần thiết sẽ sử dụng trong suốt quá trình điều tra. Giai đoạn này cung cấp một cái nhìn bao quát về các thông tin liên quan đến hệ thống bị tấn công, thông tin về hạ tầng mạng, các cơ chế bảo vệ hệ thống đó, các ứng dụng ngăn chặn xâm nhập… đang được triển khai.
        Thu thập dữ liệu: Đây là giai đoạn quan trọng quyết định sự tin cậy của kết quả khi điều tra một hệ thống máy tính bị tấn công. Tất cả dữ liệu liên quan đến hệ thống của máy tính cần được thu thập và đảm bảo được tính toàn vẹn trong suốt quá trình điều tra. Tùy vào đặc điểm, nghiệp vụ của hệ thống, người phân tích phải lựa chọn cách thu thập phù hợp. Người phân tích cần phải xác định kỹ thuật sẽ điều tra, để lựa chọn cách thu thập dữ liệu phù hợp, phải biết được khi nào thì cần thực hiện Dead Forensics, khi nào thì phải thực hiện Live Forensics để tránh vô tình phá hủy đi những dữ liệu quan trọng như dữ liệu RAM, dữ liệu mạng.
        Điều tra phân tích: Sử dụng các phương pháp nghiệp vụ, các kỹ thuật và công cụ khác nhau để trích xuất, phân tích các dữ liệu thu được để tìm kiếm các chứng cứ liên quan đến hoạt động bất hợp pháp trên hệ thống máy tính.
        Lập báo cáo: Sau khi thu thập được những chứng cứ có giá trị và có tính thuyết phục thì tất cả phải được tài liệu hóa lại rõ ràng, chi tiết và báo cáo lại cho bộ phận có trách nhiệm xử lý chứng cứ thu được, đội ngũ điều tra phải đưa ra các kỹ thuật điều tra, các công nghệ, phương thức được sử dụng, cũng như các chứng cứ thu được, tất cả phải được giải thích rõ ràng. Báo cáo phải đảm bảo tính trung lập và minh bạch).
        Xây dựng một hệ thống Lab để thực hành: Có nhiều cách để bạn dựng 1 Lab phục vụ việc nghiên cứu điều tra số, tuy nhiên mình ở đây mình đề xuất mọi người cài đặt SANS SIFT – Một môi trường điều tra số tuyệt vời, tập trung và chọn lọc lại các công cụ điều tra sau đó tích hợp sẵn trong một hệ thống, nó chứng minh rằng điều tra chuyên sâu và ứng phó với sự cố xâm nhập có thể được thực hiện bằng việc sử dụng các công cụ mã nguồn mở và cập nhật thường xuyên, bộ công cụ chọn lọc này tích hợp những công cụ chuyên dụng như Thesleuth Kit, DFF, Wireshark, Foremost, volatility, Hexeditor… Bạn có thể tải SANS SIFT tại đây. Bên cạnh công cụ có sẵn trong SANS SIFT bạn cũng cần làm quen dần các công cụ khác như FTK, OSForensics, GRR, Network Miner, PowerForensics…
        Bắt tay vào giải quyết 14 challenges của HoneyNet: Trong quá trình giải quyết challenge bạn sẽ được làm quen với nhiều kỹ thuật phân tích và các công cụ chuyên dụng khi điều tra số. Cũng trong quá trình điều tra, bạn sẽ phải tìm kiếm các nguồn thông tin hỗ trợ qua đó củng cố được nhiều kiến thức từ phân tích dữ liệu mạng, phân tích memory, phân tích file system, phân tích mã độc, khôi phục dữ liệu… Nếu bí quá thì bạn có thể tham khảo cách người khác giải quyết challenge của mình và áp dụng 1 kỹ thuật tương đương để thực hiện.</p>
    `
  },
};

// Hàm lấy tham số từ URL
function getQueryParam(param) {
  const urlParams = new URLSearchParams(window.location.search);
  return urlParams.get(param);
}

// Khi trang load xong, hiển thị bài viết theo query param
window.onload = function() {
  const postId = getQueryParam("post");
  const post = posts[postId];

  if(post) {
    document.getElementById("post-title").innerText = post.title;
    document.getElementById("post-date").innerText = post.date;
    document.getElementById("post-image").src = post.image;
    document.getElementById("post-image").alt = post.title;
    document.getElementById("post-content").innerHTML = post.content;
  } else {
    document.getElementById("post-title").innerText = "Bài viết không tồn tại";
    document.getElementById("post-date").innerText = "";
    document.getElementById("post-image").src = "";
    document.getElementById("post-image").alt = "";
    document.getElementById("post-content").innerHTML = "<p>Không tìm thấy bài viết</p>";
  }
};
document.addEventListener('DOMContentLoaded', function () {
  const form = document.querySelector('.comment-form');
  const textarea = form.querySelector('textarea');
  const commentsList = document.querySelector('.comments-list');

  form.addEventListener('submit', function (e) {
    e.preventDefault();

    const commentText = textarea.value.trim();
    if (commentText === '') {
      return;
    }
    const newComment = document.createElement('div');
    newComment.classList.add('comment-item');

    newComment.innerHTML = `
      <img src="../assets/img-avatar-1.webp" alt="Avatar" class="avatar">
      <div class="comment-content">
        <strong>Khương Ngọc Toàn</strong>
        <p>${commentText.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</p>
      </div>
    `;
    commentsList.appendChild(newComment);
    textarea.value = '';
  });
});
```

### Frontend\js\blog.js
```js
function toggleMenu() {
    const menu = document.getElementById("side-nav");
    menu.classList.toggle("active");
    document.body.classList.toggle("sidebar-open");
}

function toggleSubmenu(element) {
    const subMenu = element.nextElementSibling;
    if (subMenu && subMenu.classList.contains('sub-menu')) 
    {
        subMenu.style.display = (subMenu.style.display === 'flex') ? 'none' : 'flex';

        const icon = element.querySelector('i');
        if (icon) {
            icon.classList.toggle('fa-chevron-down');
            icon.classList.toggle('fa-chevron-up');
        }
    }
}
```

### Frontend\js\document.js
```js
// Đảm bảo chạy sau khi DOM đã sẵn sàng
document.addEventListener("DOMContentLoaded", () => {
    const stars = document.querySelectorAll("#rating-stars .star");

    stars.forEach(star => {
        star.addEventListener("click", () => {
        const val = parseInt(star.dataset.value, 10);

        stars.forEach(s => {
            const sVal = parseInt(s.dataset.value, 10);
            // Nếu giá trị <= giá trị click thì active, ngược lại bỏ active
            if (sVal <= val) {
                s.classList.add("active");
            } else {
                s.classList.remove("active");
            }
        });
    });
});
});
  
```

### Frontend\js\forgot.js
```js
document.addEventListener('DOMContentLoaded', function () {
    const forgotForm = document.getElementById('forgotForm');
    const toastElement = document.getElementById('toastForgot');
    const toast = new bootstrap.Toast(toastElement);

    forgotForm.addEventListener('submit', function (e) {
        e.preventDefault();
        
        const email = document.getElementById('forgotEmail').value;
        
        if (email.trim() !== '') {
        
            console.log("Đã gửi email đến:", email);

            toast.show();
        }
    });
});
  
```

### Frontend\js\index.js
```js
document.addEventListener("DOMContentLoaded", async () => {
    fetch('http://localhost:5000/api/user-info', {
        credentials: 'include'
    })
    .then(res => {
        if (res.status === 401) {
            // Không login
            return null;
        }
        return res.json();
    })
    .then(data => {
        if (data) {
            document.getElementById('username').textContent = data.username;
            document.getElementById('auth-buttons').style.display = 'none';
            document.getElementById('user-info').style.display = 'block';
        }
    })
    .catch(err => console.error(err));
});

```

### Frontend\js\login.js
```js
document.addEventListener("DOMContentLoaded", function () {
    // Lấy 2 ô input
    const email = document.getElementById("email");
    const passwordInput = document.getElementById("password");

    // Khi người dùng nhập vào username
    email.addEventListener("input", function () {
        email.style.border = email.value.length === 0 ? "2px solid red" : "2px solid green";
    });

    // Khi người dùng nhập vào password
    passwordInput.addEventListener("input", function () {
        passwordInput.style.border = passwordInput.value.length === 0 ? "2px solid red" : "2px solid green";
    });

    // Highlight input khi được focus
    [email, passwordInput].forEach(input => {
        input.addEventListener("focus", () => {
            input.style.backgroundColor = "#e6f7ff";
        });
        input.addEventListener("blur", () => {
            input.style.backgroundColor = "white";
        });
    });

    // Form login
    const loginForm = document.getElementById("loginForm");
    loginForm.addEventListener("submit", async (e) => {
        e.preventDefault();

        const email = document.getElementById("email").value.trim();
        const password = document.getElementById("password").value.trim();

        if (!email || !password) return;

        try {
            const response = await fetch('http://localhost:5000/api/auth/login', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                credentials: 'include',
                body: JSON.stringify({ email, password })
            });

            const data = await response.json();
            if (response.ok) {
                showToast('Đăng nhập thành công! Chào mừng ', 'success');
                setTimeout(() => {
                    window.location.href = 'index.html';
                }, 3000);  
            } else {
                showToast('Đăng nhập thất bại: ' + (data.msg || 'Lỗi không xác định'), 'error');
            }
        } catch (error) {
            showToast('Lỗi kết nối đến server: ' + error.message, 'error');
        }
    });

    // Toggle password visibility
    const togglePassword = document.getElementById("togglePassword");
    if (togglePassword) {
        togglePassword.addEventListener("click", function () {
            const isPassword = passwordInput.type === "password";
            passwordInput.type = isPassword ? "text" : "password";

            const icon = togglePassword.querySelector("i");
            icon.classList.toggle("fa-eye", !isPassword);
            icon.classList.toggle("fa-eye-slash", isPassword);
        });
    }
});

function showToast(message, type = 'success') {
    const toastE1 = document.getElementById("liveToast");
    const toastBody = toastE1.querySelector(".toast-body");

    // Xóa hết class bg- cũ, giữ lại border-0
    toastE1.classList.remove("bg-success", "bg-danger", "text-white");

    if (type === 'error') {
        toastE1.classList.add("bg-danger", "text-white");
    } else {
        toastE1.classList.add("bg-success", "text-white");
    }

    toastBody.innerHTML = message;

    const toast = new bootstrap.Toast(toastE1, {
        delay: 3000,
        autohide: true
    });

    toast.show();
}
```

### Frontend\js\main.js
```js
function toggleMenu() {
    const menu = document.getElementById("side-nav");
    menu.classList.toggle("active");
    document.body.classList.toggle("sidebar-open");
}

function toggleSubmenu(element) {
    const subMenu = element.nextElementSibling;
    if (subMenu && subMenu.classList.contains('sub-menu')) 
    {
        subMenu.style.display = (subMenu.style.display === 'flex') ? 'none' : 'flex';

        const icon = element.querySelector('i');
        if (icon) {
            icon.classList.toggle('fa-chevron-down');
            icon.classList.toggle('fa-chevron-up');
        }
    }
}
```

### Frontend\js\reset.js
```js
document.getElementById("resetForm").addEventListener("submit", function (e) {
    e.preventDefault();

    const newPassword = document.getElementById("newPassword").value;
    const confirmPassword = document.getElementById("confirmPassword").value;

    if (newPassword !== confirmPassword) {
        alert("Mật khẩu xác nhận không khớp.");
        return;
    }
    
    alert("Mật khẩu đã được đặt lại thành công!");
    window.location.href = "login.html";
});

```

### Frontend\js\set-title.js
```js
document.addEventListener("DOMContentLoaded", function () {
    // Lấy đường dẫn file
    const pathParts = window.location.pathname.split("/");
    const file = pathParts[pathParts.length - 1];  // lấy tên file (ví dụ: mon-dai-cuong.html)

    // Môn học lớn (chỉ dùng tên file không có .html)
    const majorMap = {
      "mon-dai-cuong.html": "Đại cương",
      "mon-chinh-tri.html": "Chính trị",
      "mon-co-so-nganh.html": "Cơ sở ngành",
      "mon-chuyen-nganh.html": "Chuyên ngành",
      "mon-tu-chon.html": "Tự chọn"
    };

    // Môn học nhỏ
    const minorMap = {
      "triet-hoc.html": "Triết học",
      "tu-tuong-hcm.html": "Tư tưởng Hồ Chí Minh",
      "ly-luan-chinh-tri.html": "Lý luận chính trị"
    };

    const major = majorMap[file] || "";  // Tra cứu môn học lớn
    const minor = minorMap[file] || "";  // Tra cứu môn học nhỏ

    // Cập nhật breadcrumb và title nếu tìm thấy
    if (major && minor) {
      document.title = `Tài liệu > ${major} > ${minor}`;
      const bc = document.getElementById("breadcrumb");
      if (bc) bc.textContent = `Tài liệu > ${major} > ${minor}`;
    }
});

```

### Frontend\js\signup.js
```js
const usernameInput = document.getElementById("username");
const passwordInput = document.getElementById("password");
const emailInput = document.getElementById("email");

usernameInput.addEventListener("input", function() {
    if (usernameInput.value.length == 0) {
        usernameInput.style.border = "2px solid red";
    } else {
        usernameInput.style.border = "2px solid green";
    }
});

passwordInput.addEventListener("input", function() {
    if (passwordInput.value.length == 0) {
        passwordInput.style.border = "2px solid red";
    } else {
        passwordInput.style.border = "2px solid green";
    }
});

emailInput.addEventListener("input", function() {
    if (emailInput.value.length == 0) {
        emailInput.style.border = "2px solid red";
    } else {
        emailInput.style.border = "2px solid green";
    }
});

document.getElementById("sendOtpBtn").addEventListener("click", function() {
    const email = emailInput.value;

    if (email) {
        //showToast('Mã OTP đã được gửi đến email của bạn.', 'success');

        document.getElementById("otpSection").style.display = "block";
        document.getElementById("registerBtn").disabled = false;
    } else {
        showToast('Vui lòng nhập email hợp lệ.', 'error');
    }
});

function showToast(message, type = 'success') {
    const toastE1 = document.getElementById("liveToast");
    const toastBody = toastE1.querySelector(".toast-body");

    // Xóa hết class bg- cũ, giữ lại border-0
    toastE1.classList.remove("bg-success", "bg-danger", "text-white");

    if (type === 'error') {
        toastE1.classList.add("bg-danger", "text-white");
    } else {
        toastE1.classList.add("bg-success", "text-white");
    }

    toastBody.innerHTML = message;

    const toast = new bootstrap.Toast(toastE1, {
        delay: 3000,
        autohide: true
    });

    toast.show();
}


document.addEventListener("DOMContentLoaded", function() {
    const signupForm = document.getElementById('signupForm');
    const sendOtpBtn = document.getElementById('sendOtpBtn');
    const otpSection = document.getElementById('otpSection');
    const registerBtn = document.getElementById('registerBtn');
    const backendURL = 'http://localhost:5000';

    let otpSent = false;

    sendOtpBtn.addEventListener('click', async () => {
        const email = document.getElementById('email').value.trim();
        if (!email) {
            showToast('Vui lòng nhập email hợp lệ.', 'error');
            return;
        }

        sendOtpBtn.disabled = true;
        sendOtpBtn.textContent = 'Đang gửi OTP...';

        try {
            const res = await fetch(`${backendURL}/api/auth/send-otp`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ email })
            });

            const data = await res.json();

            if (res.ok) {
                otpSection.style.display = 'block';
                registerBtn.disabled = false;
                otpSent = true;
                showToast(data.msg, 'success');
            } else {
                showToast(data.msg || 'Gửi OTP thất bại', 'error');
            }
        } catch (error) {
            showToast('Lỗi gửi OTP', 'error');
            console.error(error);
        } finally {
            sendOtpBtn.disabled = false;
            sendOtpBtn.textContent = 'Gửi mã OTP';
        }
    });

    signupForm.addEventListener('submit', async (e) => {
        e.preventDefault();

        if (!otpSent) {
            showToast('Vui lòng gửi OTP trước', 'error');
            return;
        }

        const otp = signupForm.OTP.value.trim();
        const email = signupForm.email.value.trim();

        if (!otp) {
            showToast('Vui lòng nhập mã OTP', 'error');
            return;
        }

        try {
            const res = await fetch(`${backendURL}/api/auth/verify-otp`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: "include",
                body: JSON.stringify({ email, otp })
            });

            if (!res.ok) {
                showToast("OTP không hợp lệ!", 'error');
                return;
            }

            const formData = {
                username: signupForm.username.value.trim(),
                email,
                password: signupForm.password.value.trim()
            };

            if (!formData.username || !formData.password || !formData.email) {
                showToast('Vui lòng điền đầy đủ thông tin', 'error');
                return;
            }

            registerBtn.disabled = true;
            registerBtn.textContent = 'Đang đăng ký...';

            const regRes = await fetch(`${backendURL}/api/auth/register`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(formData)
            });

            const regText = await regRes.text();

            let regData;
            try {
                regData = JSON.parse(regText);
            } catch (regParseErr) {
                console.error("Lỗi parse JSON đăng ký:", regParseErr);
                showToast("Lỗi dữ liệu phản hồi khi đăng ký.", 'error');
                return;
            }

            if (regRes.ok) {
                showToast('Đăng ký thành công! Bạn có thể đăng nhập.', 'success');
                setTimeout(() => {
                    window.location.href = 'login.html';
                }, 3000);  
            } else {
                showToast(regData.msg || 'Đăng ký thất bại', 'error');
            }
        } catch (error) {
            console.error("Lỗi khi đăng ký:", error);
            showToast('Lỗi khi đăng ký', 'error');
        } finally {
            registerBtn.disabled = false;
            registerBtn.textContent = 'Đăng ký';
        }
    });

    const togglePassword = document.getElementById("togglePassword");

    if (togglePassword && passwordInput) {
        togglePassword.addEventListener("click", function() {
            const isPassword = passwordInput.type == "password";
            passwordInput.type = isPassword ? "text" : "password";
            const icon = togglePassword.querySelector("i");
            icon.classList.toggle("fa-eye", !isPassword);
            icon.classList.toggle("fa-eye-slash", isPassword);
        });
    }
});

```

### Frontend\js\upload1.js
```js
document.addEventListener("DOMContentLoaded", function () {
    // === PHẦN UPLOAD ===
    const fileInput = document.getElementById("fileUpload");
    const afterUpload = document.getElementById("after-upload");
    const fileNameDisplay = afterUpload.querySelector(".file-info a");
    const uploadNextBtn = document.getElementById("next-btn");

    // Ẩn tên file và nút next ban đầu
    afterUpload.style.display = "none";

    fileInput.addEventListener("change", function () {
        if (fileInput.files.length > 0) {
            // Hiện tên file đầu tiên
            fileNameDisplay.textContent = fileInput.files[0].name;
            // Hiện phần chứa tên file và nút Next
            afterUpload.style.display = "flex"; // hoặc block tùy CSS bạn dùng
        } else {
            afterUpload.style.display = "none";
        }
    });

    uploadNextBtn.addEventListener("click", function () {
        document.getElementById("upload").classList.remove("active");
        document.getElementById("detail").classList.add("active");
    });


    // === PHẦN DETAIL ===
    const formDetail = document.querySelector(".form-container");
    const nextButton = formDetail.querySelector(".next-button");

    // Ẩn nút Next detail ban đầu
    nextButton.style.display = "none";

    const subjectSelect = formDetail.querySelectorAll(".detail-select")[0];
    const yearSelect = formDetail.querySelectorAll(".detail-select")[1];
    const titleInput = formDetail.querySelector(".detail-title-input");
    const descriptionInput = formDetail.querySelector("textarea");

    function validateDetailForm() {
        const subjectValid = subjectSelect.value !== "Please select";
        const yearValid = yearSelect.value !== "Please select";
        const titleValid = titleInput.value.trim() !== "";
        const descriptionValid = descriptionInput.value.trim() !== "";

        return subjectValid && yearValid && titleValid && descriptionValid;
    }

    function toggleDetailNextButton() {
        if (validateDetailForm()) {
            nextButton.style.display = "inline-block";
        } else {
            nextButton.style.display = "none";
        }
    }

    [subjectSelect, yearSelect, titleInput, descriptionInput].forEach(el => {
        el.addEventListener("input", toggleDetailNextButton);
        el.addEventListener("change", toggleDetailNextButton);
    });

    formDetail.addEventListener("submit", function (e) {
        e.preventDefault();
        if (validateDetailForm()) {
            document.getElementById("detail").classList.remove("active");
            document.getElementById("done").classList.add("active");
        }
    });


    // === PHẦN DONE ===
    const doneBtn = document.querySelector(".done-button");
    doneBtn.addEventListener("click", function () {
        window.location.href = "index.html"; // Chuyển về trang chủ hoặc bạn muốn chuyển tới đâu
    });
});
```
